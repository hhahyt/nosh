#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#    <description>
#    Copyright (C) 2015  Nico Schl√∂mer
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import argparse
import nfl
import ast
import inspect
import sympy
import re
from string import Template
import os
import enum
import logging
import importlib.machinery


def _main():
    args = _parse_cmd_arguments()

    inmod = importlib.machinery.SourceFileLoader(
        'inmod',
        args.infile
        ).load_module()

    # loop over all locally defined entities to see if there's anything we can
    # convert
    entities = []
    for name, var in inmod.__dict__.items():
        if isinstance(var, nfl.EdgeMatrix):
            entities.append(getCodeEdgeMatrix(var, name))
        elif isinstance(var, nfl.DirichletBC):
            entities.append(getCodeDirichletBC(var, name))
        elif isinstance(var, nfl.Expression):
            entities.append(getCodeExpression(var, name))
        elif isinstance(var, nfl.NonlinearOperator):
            entities.append(
                getCodeNonlinearOperator(var, name)
                )

    # Plug it all together in main
    with open('templates/main.tpl', 'r') as f:
        main_src = Template(f.read())
        main_content = main_src.substitute({
            'name': os.path.splitext(os.path.basename(args.infile))[0],
            'content': '\n'.join(entities)
            })

    # write it
    with open(os.path.splitext(args.infile)[0] + '.hpp', 'w') as f:
        f.write(main_content)

    return 0


def getCodeEdgeMatrix(eo, name):
    assert(isinstance(eo, nfl.EdgeMatrix))
    specs = inspect.getargspec(eo.edgeFunction)
    assert(len(specs.args) == 3)

    alpha = sympy.Symbol('edgeCoefficient')
    c0 = sympy.Symbol('controlVolume0')
    c1 = sympy.Symbol('controlVolume1')
    result = eo.edgeFunction(alpha, c0, c1)
    assert(len(result) == 2)
    assert(len(result[0]) == 2)
    assert(len(result[1]) == 2)

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)

    # template substitution
    with open('templates/EdgeMatrix.tpl', 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),  # class names are uppercase
            'edge00': extractCExpression(result[0][0]),
            'edge01': extractCExpression(result[0][1]),
            'edge10': extractCExpression(result[1][0]),
            'edge11': extractCExpression(result[1][1])
            })

    return code


def getCodeDirichletBC(dbc, name):
    assert(isinstance(dbc, nfl.DirichletBC))

    x = sympy.DeferredVector('x')

    result0 = dbc.isInside(x)
    result1 = dbc.eval(x)

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)

    # template substitution
    with open('templates/DirichletBC.tpl', 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),  # class names are uppercase
            'insideCondition': extractCExpression(result0),
            'evalReturnValue': extractCExpression(result1)
            })

    return code


def getCodeExpression(expr, name):
    assert(isinstance(expr, nfl.Expression))

    x = sympy.DeferredVector('x')

    result = expr.eval(x)

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)

    # template substitution
    with open('templates/Expression.tpl', 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),  # class names are uppercase
            'degree': expr.degree,
            'eval': extractCExpression(result)
            })

    return code


def getCodeNonlinearOperator(F, name):
    assert(isinstance(F, nfl.NonlinearOperator))

    debug = True
    if debug:
        logging.basicConfig(level=logging.DEBUG)

    # The dissection of nonlinear operators is unfortunately not so easy. We
    # cannot use SymPy's built-in C-code generation here, since the operator
    # may be composed of more complex operations than that the basic ones. For
    # example, the operator could involve the application of linear operator
    # defined elsewhere.
    # For this reason, we're doing the code generation manually. This involves
    #   (1) generating the abstract syntax tree, and
    #   (2) generating the code from the AST.
    #
    # Call the function and check the return value.
    generator = CodeGen2()
    u = sympy.Symbol('u')
    f_code = generator.generate(F.f(u), {'u': 'x'})
    print(f_code)

    print('-----------------------------')

    dfdp_code = generator.generate(F.dfdp(u), {'u': 'x'})
    print(dfdp_code)

    print('-----------------------------')

    u0 = sympy.Symbol('u0')
    jac_code = generator.generate(F.jac(u, u0), {'u': 'x', 'u0': 'x0'})
    print(jac_code)

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)
    # template substitution
    with open('templates/ModelEvaluator.tpl', 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),
            'description': 'description',
            'compute_f_body': f_code,
            'compute_dfdp_body': dfdp_code
            })

    print(code)
    exit()
    return code


class Pointwise(str):
    pass


class Vector(str):
    pass


class CodeGen2(object):
    def __init__(self):  # , operators, vector_args, scalar_args):
        self.arg_translate = {}
        self._intermediate_count = 0
        self._get_data = set([])
        self._code = ''
        return

    def visit(self, node, out_vector=None):
        if node.is_Add:
            return self.visit_ChainOp(node, '+')
        elif node.is_Mul:
            return self.visit_ChainOp(node, '*')
        elif node.is_Number:
            return Pointwise(node)
        elif node.is_Symbol:
            return self.visit_Name(node)
        elif node.is_Function:
            a = self.visit_Call(node)
            return a
        else:
            raise RuntimeError('Unknown node type \"', type(node), '\".')
        return

    def generate(self, node, arg_translate):
        '''Entrance point to this class.
        '''
        self.arg_translate = arg_translate
        self._intermediate_count = 0
        self._get_data = set([])
        self._code = ''
        out = self.visit(node, 'y')
        if isinstance(out, Pointwise):
            self._to_vector(out, 'y')
        return self._code

    def _get_outvector(self):
        '''Sometime, one needs to store intermediate values in vectors. This
        function provides a admissible name for an intermediate vector.
        '''
        out_vector = 'y%d' % self._intermediate_count
        self._intermediate_count += 1
        self._code += '\nTpetra::Vector<double> %s(y->getMap());' % out_vector
        return out_vector

    def _to_vector(self, pointwise_code, out_vector):
        '''This method takes pointwise code and wraps it up into a vector. The
        name of the vector containing the data is returned.
        '''
        assert(isinstance(pointwise_code, Pointwise))
        self._code += '''
auto %sData = %s.getDataNonConst();
for (size_t k = 0; k < %sData.size(); k++) {
  %sData[k] = %s;
}
''' % (out_vector, out_vector, out_vector, out_vector, pointwise_code)
        self._get_data.add(out_vector)
        return

    def _to_pointwise(self, name):
        if name not in self._get_data:
            self._code += '\nconst auto %sData = %s.getData();' % (name, name)
            self._get_data.add(name)
        return '%sData[k]' % name

    def generic_visit(self, node):
        raise RuntimeError(
            'Should never be called. __name__:', type(node).__name__
            )
        self.visit(node)
        return

    def visit_Load(self, node):
        logging.debug('> Load >')
        pass

    def visit_Call(self, node):
        '''Handles calls for operators A(u) and pointwise functions sin(u).
        '''
        id = node.func.__name__
        logging.debug('> Call %s' % id)
        # Check if this is the top (or root) of the recursion. If it is, the
        # output variable will be `y`.
        assert(len(node.args) == 1)  # one argument, e.g., A(x)
        ret = self.visit(node.args[0])
        if isinstance(node, nfl.EdgeMatrix):
            # The argument to A(.) must be of vector type.
            if isinstance(ret, Vector):
                arg_name = ret
            elif isinstance(ret, Pointwise):
                arg_name = self._get_outvector()
                self._to_vector(ret, arg_name)
            else:
                raise ValueError('Illegal input type')
            # Get the output vector
            if hasattr(node, 'out_vector'):
                out_vector = node.out_vector
            else:
                out_vector = self._get_outvector()
            # Put it all together
            self._code += '\n%s->apply(%s, %s);\n' \
                % (id, arg_name, out_vector)
            logging.debug('  Call >')
            return Vector(out_vector)
        else:
            # Assume that the operator is a C++ intrinsic or otherwise defined.
            # The argument must be of pointwise type.
            if isinstance(ret, Vector):
                a = self._to_pointwise(ret)
            elif isinstance(ret, Pointwise):
                a = ret
            else:
                raise ValueError('Illegal input type')
            logging.debug('  Call >')
            return Pointwise('%s(%s)' % (id, a))

    def visit_UnaryOp(self, node):
        '''Handles unary operations (e.g., +, -,...).
        '''
        code_op = self.visit(node.op)
        logging.debug('> UnaryOp %s' % code_op)
        ret = self.visit(node.operand)
        if isinstance(ret, Vector):
            code = self._to_pointwise(ret)
        elif isinstance(ret, Pointwise):
            code = ret
        else:
            raise ValueError('Illegal input type')
        # plug it together
        pointwise_code = '%s%s' % (code_op, code)
        logging.debug('  UnaryOp >')
        return Pointwise(pointwise_code)

    def visit_ChainOp(self, node, code_op):
        '''Handles binary operations (e.g., +, -, *,...).
        '''
        logging.debug('> BinOp %s' % code_op)
        # collect the pointwise code for left and right
        pwcode = []
        for n in node.args:
            ret = self.visit(n)
            if isinstance(ret, Vector):
                pwcode.append(self._to_pointwise(ret))
            elif isinstance(ret, Pointwise):
                pwcode.append(ret)
            else:
                raise ValueError('Illegal input type')
        # plug it together
        co = ' ' + code_op + ' '
        # TODO turn "-1 *" into unary operator
        # print(pwcode)
        pointwise_code = co.join(pwcode)
        logging.debug('  BinOp >')
        return Pointwise(pointwise_code)

    def visit_Name(self, node):
        id = node.name
        logging.debug('> Name %s >' % id)
        if id in self.arg_translate:
            return Vector(self.arg_translate[id])
        elif isinstance(node, sympy.Symbol):
            # Treat all other symbols as pointwise variables
            return Pointwise(id)
        else:
            raise ValueError(
                'Name \"%s\" not defined. Should it be an argument?' % id
                )

    def visit_Add(self, node):
        return '+'

    def visit_Sub(self, node):
        return '-'

    def visit_Mult(self, node):
        return '*'

    def visit_Div(self, node):
        return '/'

    def visit_UAdd(self, node):
        return '+'

    def visit_USub(self, node):
        return '-'

    def visit_Num(self, node):
        return Pointwise(str(node.n))


class CodeGen(ast.NodeVisitor):
    def __init__(self, operators, vector_args, scalar_args):
        self.operators = operators
        # Translation between arguments in the python conf and the template
        self.arg_translate = {
            vector_args[0]: 'x'
            }
        if len(vector_args) > 1:
            self.arg_translate[vector_args[1]] = 'x0_'
        # in the python config:
        self.conf_x_arg = vector_args[0]
        self.param_args = scalar_args

        self._intermediate_count = 0
        self._get_data = set([])
        self._code = ''
        return

    def generate(self, node):
        '''Entrance point to this class.
        '''
        node.out_vector = 'y'
        out = self.visit(node)
        if isinstance(out, Pointwise):
            self._to_vector(out, 'y')
        return self._code

    def _get_outvector(self):
        '''Sometime, one needs to store intermediate values in vectors. This
        function provides a admissible name for an intermediate vector.
        '''
        out_vector = 'y%d' % self._intermediate_count
        self._intermediate_count += 1
        self._code += '\nTpetra::Vector<double> %s(y->getMap());' % out_vector
        return out_vector

    def _to_vector(self, pointwise_code, out_vector):
        '''This method takes pointwise code and wraps it up into a vector. The
        name of the vector containing the data is returned.
        '''
        assert(isinstance(pointwise_code, Pointwise))
        self._code += '''
auto %sData = %s.getDataNonConst();
for (size_t k = 0; k < %sData.size(); k++) {
  %sData[k] = %s;
}
''' % (out_vector, out_vector, out_vector, out_vector, pointwise_code)
        self._get_data.add(out_vector)
        return

    def _to_pointwise(self, name):
        if name not in self._get_data:
            self._code += '\nconst auto %sData = %s.getData();' % (name, name)
            self._get_data.add(name)
        return '%sData[k]' % name

    def generic_visit(self, node):
        raise RuntimeError(
            'Should never be called. __name__:', type(node).__name__
            )
        self.visit(node)
        return

    def visit_Load(self, node):
        logging.debug('> Load >')
        pass

    def visit_Call(self, node):
        '''Handles calls for operators A(u) and pointwise functions sin(u).
        '''
        logging.debug('> Call %s' % node.func.id)
        # Check if this is the top (or root) of the recursion. If it is, the
        # output variable will be `y`.
        assert(len(node.args) == 1)  # one argument, e.g., A(x)
        ret = self.visit(node.args[0])
        if node.func.id in self.operators:
            # The argument to A(.) must be of vector type.
            if isinstance(ret, Vector):
                arg_name = ret
            elif isinstance(ret, Pointwise):
                arg_name = self._get_outvector()
                self._to_vector(ret, arg_name)
            else:
                raise ValueError('Illegal input type')
            # Get the output vector
            if hasattr(node, 'out_vector'):
                out_vector = node.out_vector
            else:
                out_vector = self._get_outvector()
            # Put it all together
            self._code += '\n%s->apply(%s, %s);\n' \
                % (node.func.id, arg_name, out_vector)
            logging.debug('  Call >')
            return Vector(out_vector)
        else:
            # Assume that the operator is a C++ intrinsic or otherwise defined.
            # The argument must be of pointwise type.
            if isinstance(ret, Vector):
                a = self._to_pointwise(ret)
            elif isinstance(ret, Pointwise):
                a = ret
            else:
                raise ValueError('Illegal input type')
            logging.debug('  Call >')
            return Pointwise('%s(%s)' % (node.func.id, a))

    def visit_UnaryOp(self, node):
        '''Handles unary operations (e.g., +, -,...).
        '''
        code_op = self.visit(node.op)
        logging.debug('> UnaryOp %s' % code_op)
        ret = self.visit(node.operand)
        if isinstance(ret, Vector):
            code = self._to_pointwise(ret)
        elif isinstance(ret, Pointwise):
            code = ret
        else:
            raise ValueError('Illegal input type')
        # plug it together
        pointwise_code = '%s%s' % (code_op, code)
        logging.debug('  UnaryOp >')
        return Pointwise(pointwise_code)

    def visit_BinOp(self, node):
        '''Handles binary operations (e.g., +, -, *,...).
        '''
        code_op = self.visit(node.op)
        logging.debug('> BinOp %s' % code_op)
        # collect the pointwise code for left and right
        lr_pwcode = []
        for n in [node.left, node.right]:
            ret = self.visit(n)
            if isinstance(ret, Vector):
                lr_pwcode.append(self._to_pointwise(ret))
            elif isinstance(ret, Pointwise):
                lr_pwcode.append(ret)
            else:
                raise ValueError('Illegal input type')
        # plug it together
        pointwise_code = '%s %s %s' % (lr_pwcode[0], code_op, lr_pwcode[1])
        logging.debug('  BinOp >')
        return Pointwise(pointwise_code)

    def visit_Name(self, node):
        logging.debug('> Name %s >' % node.id)
        if node.id in self.arg_translate:
            return Vector(self.arg_translate[node.id])
        elif node.id in self.param_args:
            return Pointwise(node.id)
        else:
            raise ValueError(
                'Name \"%s\" not defined. Should it be an argument?' % node.id
                )

    def visit_Add(self, node):
        return '+'

    def visit_Sub(self, node):
        return '-'

    def visit_Mult(self, node):
        return '*'

    def visit_Div(self, node):
        return '/'

    def visit_UAdd(self, node):
        return '+'

    def visit_USub(self, node):
        return '-'

    def visit_Num(self, node):
        return Pointwise(str(node.n))


def extractCExpression(expr):
    from sympy.utilities.codegen import codegen
    [(c_name, c_code), (h_name, c_header)] = codegen(("f", expr), "C")
    res = re.search("f_result = (.*);", c_code)
    return res.group(1)


def _parse_cmd_arguments():
    parser = argparse.ArgumentParser(
        description='Convert NFL files into C++ headers.'
        )
    parser.add_argument(
        'infile',
        type=str,
        help='input NFL file'
        )
    return parser.parse_args()

if __name__ == '__main__':
    _main()
