#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
import argparse
import nfl
import inspect
import sympy
import re
from string import Template
import os
import logging
import importlib.machinery
import subprocess
import sys

templates_dir = os.path.join(
    os.path.dirname(os.path.realpath(__file__)),
    'templates'
    )


def _sanitize(str):
    # turn any string into a valid variable identifier
    return re.sub('\W|^(?=\d)', '_', str)


def _main():
    args = _parse_cmd_arguments()

    inmod = importlib.machinery.SourceFileLoader(
        'inmod',
        args.infile
        ).load_module()

    # loop over all locally defined entities to see if there's anything we can
    # convert
    entities = []
    for name, var in inmod.__dict__.items():
        if is_fvm_matrix(var):
            entities.append(get_code_fvm_matrix(var, name))
        elif inspect.isclass(var) and \
                issubclass(var, nfl.DirichletBC) and \
                var != nfl.DirichletBC:
            instance = var()
            entities.append(get_code_dirichlet_bc(instance, name))
        elif inspect.isclass(var) and \
                issubclass(var, nfl.Expression) and \
                var != nfl.Expression and \
                hasattr(var, 'degree') and \
                hasattr(var, 'eval'):
            entities.append(get_code_expression(var, name))
        elif isinstance(var, nfl.Operator):
            entities.append(get_code_operator(var, name))
        elif isinstance(var, nfl.NonlinearProblem):
            entities.append(
                get_code_nonlinear_operator(var, name)
                )

    # Plug it all together in main
    with open(os.path.join(templates_dir, 'main.tpl'), 'r') as f:
        main_src = Template(f.read())
        name = os.path.splitext(os.path.basename(args.infile))[0]
        # sanitize the name
        name = _sanitize(name)
        main_content = main_src.substitute({
            'name': name,
            'name_uppercase': name.upper(),
            'content': '\n'.join(entities)
            })

    # write it
    # outfile = os.path.splitext(args.infile)[0] + '.hpp'
    with open(args.outfile, 'w') as f:
        f.write(main_content)

    # Make sure it's formatted nicely.
    # TODO check out uncrustify
    _run('astyle --style=ansi -s2 %s' % args.outfile)

    return 0


def _run(command):
    """Runs a given command on the command line and returns its output.
    """
    process = subprocess.Popen(
        command,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        close_fds=True
        )
    output = process.stdout.read()[:-1]
    ret = process.wait()

    if ret != 0:
        sys.exit(
            "\nERROR: The command \n\n%s\n\nreturned a nonzero "
            "exit status. The error message is \n\n%s\n\n"
            "Abort.\n"
            % (command, process.stderr.read()[:-1])
            )
    return output


def is_fvm_matrix(var):
    from sympy.core import function
    # The FvmMatrix class is supposed to be derived from sympy.Function so it
    # can be used in other expressions (e.g., laplace(u) + 2*u).
    # Unfortunately, subclassing from sympy.Function isn't exactly easy, cf.
    # <https://groups.google.com/forum/#!topic/sympy/X6tejUa18r8>.  Right now,
    # FvmMatrix is just an alias for sympy.Function, so we need to go the
    # extra mile here to check if we're actually dealing with an FvmMatrix.
    return isinstance(var, function.FunctionClass) and \
        (callable(getattr(var, 'edge_contrib', None)) or
         callable(getattr(var, 'vertex_contrib', None))
         )


def get_code_fvm_matrix(eo, name):
    '''Get Nosh C++ code for an FVM matrix.
    '''
    # handle the edge contributions
    x0 = sympy.MatrixSymbol('x0', 1, 3)
    x1 = sympy.MatrixSymbol('x1', 1, 3)
    edge_length = sympy.Symbol('edge_length')
    edge_covolume = sympy.Symbol('edge_covolume')
    all_symbols = set([x0, x1, edge_length, edge_covolume])
    used_symbols = set()
    used_expressions = set()
    if callable(getattr(eo, 'edge_contrib', None)):
        specs = inspect.getargspec(eo.edge_contrib)
        assert(len(specs.args) == 4)

        result = eo.edge_contrib(x0, x1, edge_length, edge_covolume)

        assert(len(result) == 2)
        assert(len(result[0]) == 2)
        assert(len(result[1]) == 2)

        # Check if any of the arguments is not used in the function.
        # (We'll declare them (void) to supress compiler warnings.)
        for r in [result[0][0], result[0][1], result[1][0], result[1][1]]:
            used_expressions = used_expressions.union(
                    [type(atom) for atom in r.atoms(nfl.Expression)]
                    )
            used_symbols = used_symbols.union(r.free_symbols)
    else:
        result = [[0, 0], [0, 0]]

    unused_symbols_edge = all_symbols - used_symbols

    # edge contribution handling done

    # handle the vertex contributions
    x = sympy.MatrixSymbol('x', 1, 3)
    vol = sympy.Symbol('control_volume')
    all_symbols = set([x, vol])
    if callable(getattr(eo, 'vertex_contrib', None)):
        specs = inspect.getargspec(eo.vertex_contrib)
        assert(len(specs.args) == 1)

        result_vertex = eo.vertex_contrib(vol)

        # Check if any of the arguments is not used in the function.
        # (We'll declare them (void) to supress compiler warnings.)
        unused_symbols = all_symbols - result_vertex.free_symbols
    else:
        result_vertex = 0.0
        unused_symbols_vertex = all_symbols
    # vertex contribution handling done

    # handle the boundary conditions
    if getattr(eo, 'boundary_conditions', None):
        bcs = eo.boundary_conditions
        for bc in bcs:
            assert(isinstance(bc, nfl.DirichletBC))
        code_bcs = \
            '{%s}' % (', '.join('std::make_shared<%s>()' %
                      type(bc).__name__.lower() for bc in bcs))
    else:
        code_bcs = '{}'
    # boundary conditions handling done

    constructor_args = [
        'const std::shared_ptr<const nosh::mesh> & _mesh'
        ]
    members_init = [
      'nosh::fvm_matrix(_mesh, %s)' % code_bcs
      ]
    members_declare = []
    # Go through all used expressions and check if they are defined. If not,
    # they need to be given as arguments to the constructor.
    for expr in used_expressions:
        constructor_args.append('const nosh::expression & _%s' % expr)
        members_init.append('%s(_%s)' % (expr, expr))
        members_declare.append('const nosh::expression & %s;' % expr)

    # template substitution
    with open(os.path.join(templates_dir, 'fvm_matrix.tpl'), 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.lower(),  # class names ara lowercase
            'edge00': extract_c_expression(result[0][0]),
            'edge01': extract_c_expression(result[0][1]),
            'edge10': extract_c_expression(result[1][0]),
            'edge11': extract_c_expression(result[1][1]),
            'edge_contrib_unused_args': '\n'.join(
                ('(void) %s;' % name) for name in unused_symbols_edge
                ),
            'vertex_contrib': extract_c_expression(result_vertex),
            'vertex_contrib_unused_args': '\n'.join(
                ('(void) %s;' % name) for name in unused_symbols_vertex
                ),
            'constructor_args': ',\n'.join(constructor_args),
            'members_init': ',\n'.join(members_init),
            'members_declare': '\n'.join(members_declare)
            })

    return code


def get_code_dirichlet_bc(dbc, name):
    assert(isinstance(dbc, nfl.DirichletBC))

    x = sympy.MatrixSymbol('x', 1, 3)

    result0 = dbc.is_inside(x)
    try:
        is_x_used_inside = x in result0.free_symbols
    except AttributeError:
        is_x_used_inside = False

    result1 = dbc.eval(x)
    try:
        is_x_used_eval = x in result1.free_symbols
    except AttributeError:
        is_x_used_eval = False

    # template substitution
    with open(os.path.join(templates_dir, 'dirichlet_bc.tpl'), 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.lower(),  # class names are lowercase
            'inside_condition': extract_c_expression(result0),
            'inside_void': '' if is_x_used_inside else '(void) x;\n',
            'eval_return_value': extract_c_expression(result1),
            'eval_void': '' if is_x_used_eval else '(void) x;\n',
            })

    return code


def get_code_expression(expr, name):
    x = sympy.DeferredVector('x')

    result = expr.eval(x)

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)

    # template substitution
    with open(os.path.join(templates_dir, 'expression.tpl'), 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.lower(),  # class names are lowercase
            'degree': expr.degree,
            'eval': extract_c_expression(result)
            })

    return code


def get_code_operator(operator, name):
    assert(isinstance(operator, nfl.Operator))

    x = sympy.DeferredVector('x')

    assert(callable(operator.eval))

    if (len(inspect.getargspec(operator.eval).args) == 1):
        generator = CodeGen()
        u = sympy.Symbol('u')
        op_code, required_ops = \
            generator.generate(operator.eval(u), {'u': 'x'})

        members = ['const std::shared_ptr<const nosh::mesh> mesh_;']
        members_init = ['mesh_(mesh)']
        for required_operator in required_ops:
            members.append(
                    'const std::shared<const Tpetra::Operator> %s;' %
                    required_operator['var_name'].lower()
                    )
            members_init.append(
                    '%s(std::make_shared<%s>(mesh))' %
                    (required_operator['var_name'].lower(),
                        required_operator['class_name'].lower())
                    )

        # TODO
        # Check if any of the arguments is not used in the function.
        # (We'll declare them (void) to supress compiler warnings.)

        # template substitution
        with open(os.path.join(templates_dir, 'operator.tpl'), 'r') as f:
            src = Template(f.read())
            code = src.substitute({
                'name': name.lower(),  # class names are lowercase
                'apply': op_code,
                'members': '\n'.join(members),
                'members_init': ',\n'.join(members_init)
                })
    elif (len(inspect.getargspec(operator.eval).args) == 2):
        code = ''
        generator = CodeGen()
        u = sympy.Symbol('u')
        u0 = sympy.Symbol('u0')
        op_code, required_ops = \
            generator.generate(operator.eval(u, u0), {'u': 'x', 'u0': 'x0_'})

        members = [
                'const std::shared_ptr<const nosh::mesh> mesh_;'
                'Tpetra::Vector<double,int,int> x0_;'
                ]
        members_init = ['mesh_(mesh)', 'x0_(x0)']
        for required_operator in required_ops:
            members.append(
                    'const std::shared<const Tpetra::Operator> %s;' %
                    required_operator['var_name'].lower()
                    )
            members_init.append(
                    '%s(std::make_shared<%s>(mesh))' %
                    (required_operator['var_name'].lower(),
                        required_operator['class_name'].lower())
                    )
        # template substitution
        template = os.path.join(templates_dir, 'operator_with_rebuild.tpl')
        with open(template, 'r') as f:
            src = Template(f.read())
            code = src.substitute({
                'name': name.lower(),  # class names are lowercase
                'apply': op_code,
                'members': '\n'.join(members),
                'members_init': ',\n'.join(members_init)
                })
    else:
        raise ValueError('Only methods with one or two arguments allowed.')

    return code


def get_code_linear_operator(operator_dict):
    '''Generate code for a linear operator (with solver and all).
    It is assumed that the input dictionary specifies everything around
    the operator. For example:
    operator_dict =
    {
      operator: lambda u: laplace,
      solver: {
        type: 'Pseudo Block CG',  # any Belos type
        parameters: {
          # a bunch of CG params
          # [...]
        },
        preconditioner: {
          # preconditioner specification
          # [...]
        }
      }
    }
    '''
    code = ''
    assert('operator' in operator_dict)
    assert(callable(operator_dict['operator']))
    generator = CodeGen()
    u = sympy.Symbol('u')
    op_code, required_ops = generator.generate(F.f(u), {'u': 'x'})
    print(op_code)

    exit()

    return code


def get_code_nonlinear_operator(F, name):
    assert(isinstance(F, nfl.NonlinearProblem))

    debug = True
    if debug:
        logging.basicConfig(level=logging.DEBUG)

    # The dissection of nonlinear operators is unfortunately not so easy. We
    # cannot use SymPy's built-in C-code generation here, since the operator
    # may be composed of more complex operations than the basic ones. For
    # example, the operator could involve the application of linear operator
    # defined elsewhere.
    # For this reason, we're doing the code generation manually. This involves
    #   (1) generating the abstract syntax tree, and
    #   (2) generating the code from the AST.
    #
    # Call the function and check the return value.
    generator = CodeGen()
    u = sympy.Symbol('u')
    f_code, required_ops = generator.generate(F.f(u), {'u': 'x'})
    print(f_code)

    print('-----------------------------')

    if F.dfdp:
        dfdp_code, required_ops = generator.generate(F.dfdp(u), {'u': 'x'})
        print(dfdp_code)
        print('-----------------------------')

    if F.jac:
        u0 = sympy.Symbol('u0')
        jac_code, required_ops = generator.generate(
            F.jac(u, u0),
            {'u': 'x', 'u0': 'x0_'}
            )
        print(jac_code)
        print('-----------------------------')

    print(F)
    if F.prec:
        prec_code = get_preconditioner_code(F.prec)
        print(prec_code)
        print('-----------------------------')

    print('lulz')
    exit()

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)
    # template substitution
    with open(os.path.join(templates_dir, 'ModelEvaluator.tpl'), 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),
            'description': 'description',
            'compute_f_body': f_code,
            'compute_dfdp_body': dfdp_code,
            'belos_options_code': belos_options_code
            })

    print(code)

    with open(os.path.join(templates_dir, 'jacobian.tpl'), 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title() + 'Jacobian',
            'description': 'description',
            'body': jac_code,
            })

    print(code)
    exit()
    return code


def get_preconditioner_code(prec):
    op = prec(u0)
    assert(is_fvm_matrix(op))
    init_code = ',%s_(%s(mesh, x0))\n' \
        % (str(op), str(op).capitalize())
    print(init_matrix_code)

    if prec['solver']['type'] == 'Muelu':
        # Muelu-only preconditioner
        declare_prec_code, init_prec_code, rebuild_prec_code = \
            get_muelu_code(prec['solver']['parameters'])

        apply_prec_code = '''
#ifndef NDEBUG
  TEUCHOS_ASSERT(!MueluPrec_.is_null());
#endif
return MueluPrec_->apply(X, Y);
'''
    else:
        # Assume that we have a Belos Krylov method à la "Pseudo Block CG".
        parameters = ''
        for key, value in prec['solver']['parameters'].items():
            parameters += 'params.set("%s", %s)' % (key, to_c_string(value))

        set_preconditioner = ''
        if prec['solver']['preconditioner']:
            tp = prec['solver']['preconditioner']['type']
            if tp == 'Muelu':
                declare_code, init_code, rebuild_code = \
                    get_muelue_code(prec['solver']['parameters'])
            else:
                raise ValueError(
                    'Illegal Belos preconditioner type "%s".' % tp
                    )

        with open(os.path.join(templates_dir, 'Belos.tpl'), 'r') as f:
            src = Template(f.read())
            rebuild_code = src.substitute({
                'set_parameters': parameters,
                'operator': str(op),
                'set_preconditioner': set_preconditioner,
                'method': prec['solver']['type'].replace(' ', '')
                })

    with open(os.path.join(templates_dir, 'Preconditioner.tpl'), 'r') as f:
        src = Template(f.read())
        prec_code = src.substitute({
            'name': name.title(),
            'init_matrix': init_matrix_code,
            'apply_prec_code': apply_prec_code,
            'rebuild_code': rebuild_code
            })
    return prec_code


def get_muelu_code(parameters):
    declare_code = \
        'Teuchos::RCP<MueLu::TpetraOperator<double,int,int>> MueluPrec_;'
    init_code = 'MueluPrec_(Teuchos::null)'

    parameters = ''
    for key, value in prec['solver']['parameters'].items():
        parameters += 'params.set("%s", %s)' % (key, to_c_string(value))

    with open(os.path.join(templates_dir, 'RebuildMuelu.tpl'), 'r') as f:
        src = Template(f.read())
        rebuild_code = src.substitute({
            'muelu_parameter_set': parameters,
            'matrix': str(op) + '_'
            })

    return declare_code, init_code, rebuild_code


def to_c_string(val):
    if isinstance(val, str):
        return '"' + val + '"'
    else:
        return str(val)


def dict_to_beloscode(belos_options):
    '''Converts a Python options dictionary into a C++ code setting Belos
    options.
    '''
    code = ''
    code += 'belosList.set("Solver Type", "%s")' % belos_options['type']

    if belos_options['parameters']:
        code += '''
auto & solverList = belosList.sublist("Solver Types").sublist("%s");
''' % belos_options['type']
        for key, value in belos_options['parameters'].items():
            code += 'solverList.set("%s", %r);\n' % (key, value)

    return code


class Pointwise(str):
    pass


class Vector(str):
    pass


class CodeGen(object):
    def __init__(self):  # , operators, vector_args, scalar_args):
        self.arg_translate = {}
        self._intermediate_count = 0
        self._get_data = set([])
        self._code = ''
        self._required_operators = []
        return

    def visit(self, node, out_vector=None):
        print('node', node, type(node))
        if isinstance(node, int):
            return Pointwise(node)
        elif isinstance(node, float):
            return Pointwise(node)
        elif isinstance(node, sympy.Basic):
            if node.is_Add:
                return self.visit_ChainOp(node, '+')
            elif node.is_Mul:
                return self.visit_ChainOp(node, '*')
            elif node.is_Number:
                return Pointwise(node)
            elif node.is_Symbol:
                return self.visit_Name(node)
            elif node.is_Function:
                a = self.visit_Call(node)
                return a

        raise RuntimeError('Unknown node type \"', type(node), '\".')
        return

    def generate(self, node, arg_translate):
        '''Entrance point to this class.
        '''
        self.arg_translate = arg_translate
        self._intermediate_count = 0
        self._get_data = set([])
        self._code = ''
        self._required_operators = []
        out = self.visit(node, 'y')
        if isinstance(out, Pointwise):
            self._to_vector(out, 'y')
        return self._code, self._required_operators

    def _get_outvector(self):
        '''Sometime, one needs to store intermediate values in vectors. This
        function provides a admissible name for an intermediate vector.
        '''
        out_vector = 'y%d' % self._intermediate_count
        self._intermediate_count += 1
        self._code += '\nTpetra::Vector<double> %s(y->getMap());' % out_vector
        return out_vector

    def _to_vector(self, pointwise_code, out_vector):
        '''This method takes pointwise code and wraps it up into a vector. The
        name of the vector containing the data is returned.
        '''
        assert(isinstance(pointwise_code, Pointwise))
        self._code += '''
auto %sData = %s.getDataNonConst();
for (size_t k = 0; k < %sData.size(); k++) {
  %sData[k] = %s;
}
''' % (out_vector, out_vector, out_vector, out_vector, pointwise_code)
        self._get_data.add(out_vector)
        return

    def _to_pointwise(self, name):
        if name not in self._get_data:
            self._code += '\nconst auto %sData = %s.getData();' % (name, name)
            self._get_data.add(name)
        return '%sData[k]' % name

    def generic_visit(self, node):
        raise RuntimeError(
            'Should never be called. __name__:', type(node).__name__
            )
        self.visit(node)
        return

    def visit_Load(self, node):
        logging.debug('> Load >')
        pass

    def visit_Call(self, node):
        '''Handles calls for operators A(u) and pointwise functions sin(u).
        '''
        id = node.func.__name__
        logging.debug('> Call %s' % id)
        # Check if this is the top (or root) of the recursion. If it is, the
        # output variable will be `y`.
        assert(len(node.args) == 1)  # one argument, e.g., A(x)
        ret = self.visit(node.args[0])
        if isinstance(node, nfl.FvmMatrix):
            # The argument to A(.) must be of vector type.
            if isinstance(ret, Vector):
                arg_name = ret
            elif isinstance(ret, Pointwise):
                arg_name = self._get_outvector()
                self._to_vector(ret, arg_name)
            else:
                raise ValueError('Illegal input type')
            # Get the output vector
            if hasattr(node, 'out_vector'):
                out_vector = node.out_vector
            else:
                out_vector = self._get_outvector()
            # Put it all together
            self._code += '\n%s->apply(%s, %s);\n' \
                % (id + '_', arg_name, out_vector)
            self._required_operators.append({
                'var_name': id + '_',
                'class_name': id,
                })
            logging.debug('  Call >')
            return Vector(out_vector)
        else:
            # Assume that the operator is a C++ intrinsic or otherwise defined.
            # The argument must be of pointwise type.
            if isinstance(ret, Vector):
                a = self._to_pointwise(ret)
            elif isinstance(ret, Pointwise):
                a = ret
            else:
                raise ValueError('Illegal input type')
            logging.debug('  Call >')
            return Pointwise('%s(%s)' % (id, a))

    def visit_UnaryOp(self, node):
        '''Handles unary operations (e.g., +, -,...).
        '''
        code_op = self.visit(node.op)
        logging.debug('> UnaryOp %s' % code_op)
        ret = self.visit(node.operand)
        if isinstance(ret, Vector):
            code = self._to_pointwise(ret)
        elif isinstance(ret, Pointwise):
            code = ret
        else:
            raise ValueError('Illegal input type')
        # plug it together
        pointwise_code = '%s%s' % (code_op, code)
        logging.debug('  UnaryOp >')
        return Pointwise(pointwise_code)

    def visit_ChainOp(self, node, code_op):
        '''Handles binary operations (e.g., +, -, *,...).
        '''
        logging.debug('> BinOp %s' % code_op)
        # collect the pointwise code for left and right
        pwcode = []
        for n in node.args:
            ret = self.visit(n)
            if isinstance(ret, Vector):
                pwcode.append(self._to_pointwise(ret))
            elif isinstance(ret, Pointwise):
                pwcode.append(ret)
            else:
                raise ValueError('Illegal input type')
        # plug it together
        co = ' ' + code_op + ' '
        # TODO turn "-1 *" into unary operator
        # print(pwcode)
        pointwise_code = co.join(pwcode)
        logging.debug('  BinOp >')
        return Pointwise(pointwise_code)

    def visit_Name(self, node):
        id = node.name
        logging.debug('> Name %s >' % id)
        if id in self.arg_translate:
            return Vector(self.arg_translate[id])
        elif isinstance(node, sympy.Symbol):
            # Treat all other symbols as pointwise variables
            return Pointwise(id)
        else:
            raise ValueError(
                'Name \"%s\" not defined. Should it be an argument?' % id
                )

    def visit_Add(self, node):
        return '+'

    def visit_Sub(self, node):
        return '-'

    def visit_Mult(self, node):
        return '*'

    def visit_Div(self, node):
        return '/'

    def visit_UAdd(self, node):
        return '+'

    def visit_USub(self, node):
        return '-'

    def visit_Num(self, node):
        return Pointwise(str(node.n))


def extract_c_expression(expr):
    from sympy.utilities.codegen import codegen
    [(c_name, c_code), (h_name, c_header)] = codegen(("f", expr), "C")
    res = re.search("f_result = (.*);", c_code)
    return res.group(1)


def _parse_cmd_arguments():
    parser = argparse.ArgumentParser(
        description='Convert NFL files into C++ headers.'
        )
    parser.add_argument(
        'infile',
        type=str,
        help='input NFL file'
        )
    parser.add_argument(
        'outfile',
        type=str,
        help='output C++ header file'
        )
    return parser.parse_args()

if __name__ == '__main__':
    _main()
