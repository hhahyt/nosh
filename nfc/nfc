#!/usr/bin/env python3
# -*- coding: utf-8 -*-
#
#    <description>
#    Copyright (C) 2015  Nico Schl√∂mer
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
import argparse
import nfl
import ast
import inspect
import sympy
import re
from string import Template
import os
import enum

def _main():
    args = _parse_cmd_arguments()

    # http://stackoverflow.com/a/437857/353337
    global_vars = {}
    local_vars = {}
    namespace = {}
    with open(args.infile) as f:
        code = compile(f.read(), args.infile, 'exec')
        exec(code, global_vars, local_vars)

    # loop over the local variables and see if there's anything we can convert
    entities = []
    for name, local_var in local_vars.items():
        if isinstance(local_var, nfl.EdgeMatrix):
            entities.append(getCodeEdgeMatrix(local_var, name))
        elif isinstance(local_var, nfl.DirichletBC):
            entities.append(getCodeDirichletBC(local_var, name))
        elif isinstance(local_var, nfl.Expression):
            entities.append(getCodeExpression(local_var, name))
        elif isinstance(local_var, nfl.NonlinearOperator):
            entities.append(
                getCodeNonlinearOperator(local_var, name, local_vars)
                )

    # Plug it all together in main
    with open('templates/main.tpl', 'r') as f:
        main_src = Template(f.read())
        main_content = main_src.substitute({
            'name': os.path.splitext(os.path.basename(args.infile))[0],
            'content': '\n'.join(entities)
            })

    # write it
    with open(os.path.splitext(args.infile)[0] + '.hpp', 'w') as f:
        f.write(main_content)

    return 0


def getCodeEdgeMatrix(eo, name):
    assert(isinstance(eo, nfl.EdgeMatrix))
    specs = inspect.getargspec(eo.edgeFunction)
    assert(len(specs.args) == 3)

    alpha = sympy.Symbol('edgeCoefficient')
    c0 = sympy.Symbol('controlVolume0')
    c1 = sympy.Symbol('controlVolume1')
    result = eo.edgeFunction(alpha, c0, c1)
    assert(len(result) == 2)
    assert(len(result[0]) == 2)
    assert(len(result[1]) == 2)

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)

    # template substitution
    with open('templates/EdgeMatrix.tpl', 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),  # class names are uppercase
            'edge00': extractCExpression(result[0][0]),
            'edge01': extractCExpression(result[0][1]),
            'edge10': extractCExpression(result[1][0]),
            'edge11': extractCExpression(result[1][1])
            })

    return code


def getCodeDirichletBC(dbc, name):
    assert(isinstance(dbc, nfl.DirichletBC))

    x = sympy.DeferredVector('x')

    result0 = dbc.isInside(x)
    result1 = dbc.eval(x)

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)

    # template substitution
    with open('templates/DirichletBC.tpl', 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),  # class names are uppercase
            'insideCondition': extractCExpression(result0),
            'evalReturnValue': extractCExpression(result1)
            })

    return code


def getCodeExpression(expr, name):
    assert(isinstance(expr, nfl.Expression))

    x = sympy.DeferredVector('x')

    result = expr.eval(x)

    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)

    # template substitution
    with open('templates/Expression.tpl', 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),  # class names are uppercase
            'degree': expr.degree,
            'eval': extractCExpression(result)
            })

    return code


def getCodeNonlinearOperator(F, name, local_vars):
    assert(isinstance(F, nfl.NonlinearOperator))

    # The dissection of nonlinear operators is unfortunately not so easy. We
    # cannot use SymPy's built-in C-code generation here, since the operator
    # may be composed of more complex operatations than that the basic ones.
    # For example, the operator could involve the application of linear
    # operator defined elsewhere.
    # For this reason, we're doing the code generation manually. This involves
    #   (1) generating the abstract syntax tree, and
    #   (2) generating the code from the AST.
    #
    tree = ast.parse(inspect.getsource(F.evalu))
    # Parse the tree and generate the code along the way.
    assert(len(tree.body) == 1)
    assert(isinstance(tree.body[0], ast.FunctionDef))
    assert(len(tree.body[0].args.args) == 1)
    assert(len(tree.body[0].body) == 1)
#    compute_f_body, type, _ = \
#        recursiveCodeGen(tree.body[0].body[0].value, local_vars)
#    assert(type == 'vector')
#    compute_f_body = '''
#const auto xData = x->getData();
#auto yData = y->getDataNonConst();
##ifndef NDEBUG
#TEUCHOS_ASSERT_EQUALITY(xData.size(), yData.size());
##endif
#y->putScalar(0.0);
#''' + compute_f_body
#    print(compute_f_body)
#    exit()

    # collect operators
    operators = []
    for id, local_var in local_vars.items():
        if isinstance(local_var, nfl.EdgeMatrix):
            operators.append(id)
    assert(len(tree.body[0].args.args) == 1)
    x = v(operators, 'x', 'y', tree.body[0].args.args[0].arg)
    out_name, loopcode = x.visit(tree.body[0].body[0].value)
    code = x.code
    if loopcode:
        code += '''
for (size_t k = 0; k < yData.size(); k++) {
  yData[k] += %s;
}''' % loopcode
    print(code)
    exit()

    # Jacobian
    tree = ast.parse(inspect.getsource(F.jac))
    # Parse the tree and generate the code along the way.
    assert(len(tree.body) == 1)
    assert(isinstance(tree.body[0], ast.FunctionDef))
    assert(len(tree.body[0].args.args) == 2)
    assert(len(tree.body[0].body) == 1)
    #jac_body, type, _ = \
    #    recursiveCodeGen(tree.body[0].body[0].value, local_vars)
    #assert(type == 'vector')
    #print(jac_body)

    x = v(local_vars)
    code, type = x.visit(tree)
    assert(type == Type.vector)
    print(code)
    exit()
    # TODO
    # Check if any of the arguments is not used in the function.
    # (We'll declare them (void) to supress compiler warnings.)
    # template substitution

    with open('templates/ModelEvaluator.tpl', 'r') as f:
        src = Template(f.read())
        code = src.substitute({
            'name': name.title(),
            'description': 'description',
            'compute_f_body': compute_f_body
            })

    return code


class Type(enum.Enum):
    pointwise = 1
    vector = 2


class v(ast.NodeVisitor):
    def __init__(self, operators, invar, outvar, confvar):
        self.operators = operators
        # sync with template:
        self.invar = invar
        self.outvar = outvar
        self.confvar = confvar

        self.intermediate_count = 0

        self.mode = Type.vector

        self.code = '''const auto xData = x->getData();
auto yData = y->getDataNonConst();
#ifndef NDEBUG
TEUCHOS_ASSERT_EQUALITY(xData.size(), yData.size());
#endif
y->putScalar(0.0);
'''
        return

    def wrap(self, loopcode):
        out_name = 'y%d' % self.intermediate_count
        self.code += '''
Tpetra::Vector<double> %s(y->getMap());
auto %sData = %s.getDataNonConst();
for (size_t k = 0; k < %sData.size(); k++) {
  %sData[k] = %s;
}
''' % (out_name, out_name, out_name, out_name, out_name, loopcode)
        self.intermediate_count += 1
        return out_name, None

    def generic_visit(self, node):
        raise RuntimeError(
            'Should never be called. __name__:',
            type(node).__name__
            )
        self.visit(node)
        return

    def visit_Load(self, node):
        pass

    def visit_Call(self, node):
        print('> Call ', node.func.id)
        assert(len(node.args) == 1)  # one argument, e.g., A(x)
        arg_name, loopcode = self.visit(node.args[0])
        if node.func.id in self.operators:
            # The argument to A(.) must be of vector type.
            if loopcode:
                arg_name, _ = self.wrap(loopcode)
            out_name = 'y%d' % self.intermediate_count
            self.code += '''
Tpetra::Vector<double> %s(y->getMap());
%s->apply(%s, %s);
const auto %sData = %s.getData();
''' % (out_name, node.func.id, arg_name, out_name, out_name, out_name)
            self.intermediate_count += 1
            print('  Call >')
            return out_name, None
        else:
            # Assume that the operator is a C++ intrinsic.
            if arg_name:
                a = arg_name + 'Data[k]'
            else:
                a = loopcode
            print('  Call >')
            return None, '%s(%s)' % (node.func.id, a)

    def visit_BinOp(self, node):
        print('> BinOp')
        left_name, loopcode_left = self.visit(node.left)
        if left_name:
            loopcode_left = left_name + 'Data[k]'
        code_op = self.visit(node.op)
        right_name, loopcode_right = self.visit(node.right)
        if right_name:
            loopcode_right = right_name + 'Data[k]'
        loopcode = '%s %s %s' % (loopcode_left, code_op, loopcode_right)
        print('  BinOp >')
        return None, loopcode

    def visit_Name(self, node):
        print('> Name', node.id, '>')
        if (node.id == self.confvar):
            # Translate Python invar to template invar
            return self.invar, None
        else:
            return node.id, None

    def visit_Add(self, node):
        return '+'

    def visit_Sub(self, node):
        return '-'

    def visit_Mult(self, node):
        return '*'

    def visit_Div(self, node):
        return '/'

    def visit_Num(self, node):
        return None, str(node.n)


def extractCExpression(expr):
    from sympy.utilities.codegen import codegen
    [(c_name, c_code), (h_name, c_header)] = codegen(("f", expr), "C")
    res = re.search("f_result = (.*);", c_code)
    return res.group(1)


def _parse_cmd_arguments():
    parser = argparse.ArgumentParser(
        description='Convert NFL files into C++ headers.'
        )
    parser.add_argument(
        'infile',
        type=str,
        help='input NFL file'
        )
    return parser.parse_args()

if __name__ == '__main__':
    _main()
